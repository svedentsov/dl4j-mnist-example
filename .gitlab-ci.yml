# Этот файл представляет собой пример CI/CD пайплайна для GitLab.
# Он демонстрирует лучшие практики: разделение на стадии, кэширование,
# статический анализ, тестирование и сборку Docker-образа.

# Определяем стадии, которые будут выполняться последовательно.
stages:
  - build
  - test
  - security-scan
  - package

# --- Шаблон для Java-задач ---
# Используем якоря YAML (&) для переиспользования конфигурации.
.java-job: &java-job
  image: maven:3.9.6-eclipse-temurin-17 # Используем официальный образ Maven с Java 17
  variables:
    # Указываем Maven использовать локальную директорию для зависимостей,
    # что упрощает кэширование.
    MAVEN_OPTS: "-Dmaven.repo.local=.m2/repository"
  cache:
    # Кэшируем загруженные зависимости между запусками пайплайна,
    # что значительно ускоряет сборку.
    key: "${CI_JOB_NAME}"
    paths:
      - .m2/repository/
      - target/

# --- Стадия 1: Сборка и компиляция ---
build-job:
  stage: build
  <<: *java-job
  script:
    # Загружаем все зависимости и компилируем исходный код.
    # `dependency:go-offline` помогает эффективно кэшировать зависимости.
    - mvn dependency:go-offline
    - mvn compile

# --- Стадия 2: Тестирование ---
unit-test-job:
  stage: test
  <<: *java-job
  script:
    # Запускаем только unit-тесты.
    # Плагин `maven-surefire-plugin` настроен в pom.xml, чтобы исключать *IT.java.
    - mvn test
  artifacts:
    # Сохраняем отчеты о тестах для анализа в GitLab UI.
    when: always
    reports:
      junit:
        - target/surefire-reports/TEST-*.xml

integration-test-job:
  stage: test
  <<: *java-job
  script:
    # Запускаем только интеграционные тесты.
    # Плагин `maven-failsafe-plugin` настроен в pom.xml, чтобы включать только *IT.java.
    # Фаза `verify` нужна для запуска `integration-test` и `verify` целей Failsafe.
    - mvn verify
  artifacts:
    when: always
    reports:
      junit:
        - target/failsafe-reports/TEST-*.xml

# --- Стадия 3: Сканирование безопасности ---
static-analysis-job:
  stage: security-scan
  <<: *java-job
  script:
    # Запускаем статический анализ кода с помощью SpotBugs.
    # Сборка упадет, если будут найдены критические ошибки.
    - mvn spotbugs:check
  allow_failure: false # Важно: не пропускать ошибки безопасности

dependency-check-job:
  stage: security-scan
  <<: *java-job
  script:
    # Сканируем зависимости на известные уязвимости (CVE).
    # Сборка упадет, если найдена уязвимость с CVSS >= 7.0 (настроено в pom.xml).
    - mvn org.owasp:dependency-check-maven:check
  artifacts:
    # Сохраняем HTML-отчет для детального анализа.
    paths:
      - target/dependency-check-report.html
    when: always
  allow_failure: false

# --- Стадия 4: Упаковка приложения ---
package-job:
  stage: package
  <<: *java-job
  script:
    # Обучаем модель. Этот шаг можно вынести в отдельный пайплайн "ML Training",
    # а здесь использовать готовый артефакт. Для простоты он включен сюда.
    - echo "Обучение модели (может занять несколько минут)..."
    - mvn compile exec:java -Dexec.mainClass="com.mlops.example.training.MainTrainer" -Dexec.args="-e 1" # Уменьшаем кол-во эпох для CI
    
    # Собираем финальный JAR-файл. Пропускаем тесты, т.к. они уже пройдены.
    - mvn package -Dmaven.test.skip=true
  artifacts:
    # Сохраняем JAR-файл и модель как артефакты этой задачи.
    paths:
      - target/*.jar
      - pretrained_mnist_model.zip

# В реальном проекте здесь была бы стадия 'deploy' для сборки и публикации
# Docker-образа в реестр (например, GitLab Container Registry).
# Пример:
#
# build-docker-image:
#   stage: deploy
#   image: docker:20.10.16
#   services:
#     - docker:20.10.16-dind
#   script:
#     - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#     - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
#     - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
